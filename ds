#!/usr/bin/env python

import argparse
import csv
import re
import os

import curses

class InteractiveSearch:
    def __init__(self, bookmarks, none=None):
        self.bookmarks = sorted(bookmarks)
        self.line_buffer = []
        curses.wrapper(self.main)

    def main(self, screen):
        curses.nonl()
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_YELLOW)
        curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLACK)
        self.screen = screen
        self.lines, self.cols = self.screen.getmaxyx()

        done = False
        while not done:
            self.update_screen()
            ch = self.screen.getch()
            line, done = self.process_key(ch)

    def process_key(self, ch):
        KEY_ENTER = 13
        KEY_BACKSPACE = 127

        done = False
        if ch == KEY_ENTER:
            done = True
        elif ch == KEY_BACKSPACE:
            del self.line_buffer[-1]
        elif self.char_allowed(ch):
            self.line_buffer.append(chr(ch))

        return self.line_buffer, done

    @staticmethod
    def char_allowed(ch):
        allowed = False

        if ch >= 65 and ch<= 90:
            # uppercase letters
            allowed = True
        elif ch >= 97 and ch <= 122:
            # lowercase letters
            allowed = True
        elif ch >= 48 and ch <= 57:
            # digits
            allowed = True
        elif ch == 32 or ch == 45 or ch == 95:
            # dash, space or underscore
            allowed = True

        return allowed


    def update_screen(self):
        self.screen.clear()

        self.display_bookmarks()
        self.display_line_buffer()

        self.screen.refresh()

    def display_line_buffer(self):
        self.screen.addstr(self.lines - 1, 0, ''.join(self.line_buffer))

    def display_bookmarks(self):
        filtered_bookmarks = filter_shortcuts(self.bookmarks, ''.join(self.line_buffer))
        filter_regex = match_to_regex(''.join(self.line_buffer))
        num_bookmarks = len(filtered_bookmarks)
        i = self.lines - num_bookmarks - 1
        for bookmark in filtered_bookmarks:

            self.__display_bookmark(i, 0, bookmark, filter_regex)
            i += 1

    def __display_bookmark(self, y, x, bookmark, regex):
        """Takes a bookmark and a regex object and displays it
           in curses window, highlighting matched parts"""
        # tab padding between nickname and directory name
        padding = 16 - len(bookmark[0])
        highlight_attribute = curses.color_pair(1)

        self.screen.addstr(y, x, '[{}]{}{}'.format(bookmark[0], ' '*padding, bookmark[1]), curses.color_pair(2))

        # highlight matched parts
        match_result = regex.match(bookmark[0])
        if match_result and match_result.lastindex:
            for i in range(1, match_result.lastindex + 1):
                self.screen.addstr(y, match_result.start(i) + x + 1, match_result.group(i), highlight_attribute)

        match_result = regex.match(bookmark[1])
        if match_result and match_result.lastindex:
            for i in range(1, match_result.lastindex + 1):
                self.screen.addstr(y, match_result.start(i) + x + 2 + 16, match_result.group(i), highlight_attribute)

bookmark_path = os.path.join(os.environ['HOME'],".dir-short.bookmarks")
delimiter = ':'
bash_null_cmd = ':'
bash_cd_cmd = 'cd "{}"'

def bash_print(string):
    bash_print_cmd = 'printf "{}\\n";'
    print(bash_print_cmd.format(string))

def find(bookmarks, match):
    print_shortcuts(filter_shortcuts(bookmarks, match))

def save(bookmarks, bookmark):
    cwd = os.getcwd()
    bash_print("saved [" + bookmark + "] " + cwd)
    bookmark_directory(bookmarks, cwd, bookmark)

def parse_args():
    parser = argparse.ArgumentParser(
            description='Small utility for quickly navigating between directories')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-l','--list', action='store_true',
            help='list bookmarked directories')
    group.add_argument('-s','--save', nargs='?', metavar='nickname',
            help='bookmark current directory with optional nickname')
    group.add_argument('filter', nargs='?',
            help='string that saved directories will be matched against')
    args = parser.parse_args()

    if args.save:
        operation = save
        argument = args.save
    elif args.filter:
        operation = find
        argument = args.filter
    elif args.list:
        operation = print_shortcuts
        argument = None
    else:
        # here goes interactive operation
        operation = InteractiveSearch
        argument = None

    return operation, argument

def load_shortcuts():
    bookmarks = set()

    try:
        with open(bookmark_path,'r') as bookmark_file:
            bookmark_reader = csv.reader(bookmark_file, delimiter=delimiter)
            for bookmark in bookmark_reader:
                bookmarks.add((bookmark[0],bookmark[1]))
    except FileNotFoundError:
        pass

    return bookmarks

def save_shortcuts(bookmarks):
    with open(bookmark_path,'w',newline='') as bookmark_file:
        bookmark_writer = csv.writer(bookmark_file, delimiter=delimiter, quoting=csv.QUOTE_MINIMAL)
        for bookmark in bookmarks:
            bookmark_writer.writerow(bookmark)

def bookmark_directory(bookmarks, directory, nickname=''):
    """Adds 'directory' to bookmark list with optional 'nickname'"""
    bookmark = (nickname,directory)
    bookmarks.add(bookmark)
    save_shortcuts(bookmarks)

def match_to_regex(match):
    """Convert matcher string into a regex. It matches any group of
       characters in place of whitespace"""
    match_groups = [r'({})'.format(x) for x in match.split()]
    match_string = r'.*'.join(match_groups)
    return re.compile(r'^.*{}.*$'.format(match_string))

def filter_shortcuts(shortcuts, match):
    """Filter shortcuts that match the supplied string. Every space
       in the string matches any group of one or more characters i.e.
       'tmp py' matches '/home/user/tmp/python/projects'"""
    regex = match_to_regex(match)
    filtered_shortcuts = [x for x in shortcuts if regex.match(x[0]) or regex.match(x[1])]
    return filtered_shortcuts

def print_shortcuts(shortcuts, none=None):
    for shortcut in sorted(shortcuts):
        if len(shortcut[0]) < 8:
            tabs = 2
        else:
            tabs = 1

        bash_print('{}{}{}'.format(shortcut[0], '\\t'*tabs, shortcut[1]))

if __name__ == '__main__':
    operation, argument = parse_args()

    bookmarks = load_shortcuts()

    operation(bookmarks, argument)
